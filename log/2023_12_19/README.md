## 회원 table의 PK를 회원ID로 하면 어떤 문제가 생길까?
```
회원 정보 테이블을 만들 적에  

대부분 하나의 테이블에 사용자 정보 ( 이름/전화번호/주소/이메일 등등 ) 을 모두 몰아 넣는 경우가 있는데

이는 좋지 않은 방법이다.

 

안좋은 케이스를 예로 들자면

회원 테이블 하나만  유출 된다 하더라도  모든 회원 정보가 유출 되는 결과가 발생한다.


 

때문에 개인 정보마다 하나의 테이블을 생성 한 후에

각각의 유저마다 구분되는 키값으로 릴레이션을 거는 것이 좋다.

 

유저마다 구분되는 키값으로 보통 사용자 아이디를 생각하는 경우가 많은데

이 또한 그다지 좋은 방법은 아니다.

 

예를 들어 사용자 아이디를 PK로 사용할 경우에

사용자가 탈퇴를 하게 되면 곤란한 경우가 생긴다.

( 탈퇴한 사용자 정보를 삭제할 것인지, 보관할것인지

  어떻게 취급 할지도 함께 생각해 봐야 할 문제. )

 

탈퇴한 사용자의 아이디를 그 후에 가입한 사용자가 다시 사용한다고 생각해 보자.

분명 탈퇴한 사용자와 새로 가입한 사용자는 아이디는 같을지 모르겠지만 다른 사용자다.

그런데 이럴 경우 예전에 썼던 글을 사용자 아이디로 검색 해보면

이전 사용자가 썼던 글들이 검색되는 경우가 발생한다.

 

때문에 사용자 아이디도 유니크한 값으로 취급 되어야 겠지만

PK는 겹치지 않는 값 ( 예를 들어 난수를 발생시킨다거나) 으로 사용하는 것이 좋다.

 

PK로 겹치지 않는 값을 사용하며, 이 값을 가지고 다닌다면

위와 같은 상황에서도 아이다가 같다해도 구분되는 PK값은 다르기 때문에

예전 탈퇴한 사용자의 글이 검색되는 일은 없을 것이다.

 

비밀번호나 주민등록번호등의 개인 정보를 보관 할 때에는

해쉬알고리즘을 사용하거나 (MD5나 SHA1 등) 해야지 암호화는 하지 말아야 한다.

암호화 한다는 말은 복호화가 가능하다는 말과 동일하다.

 

자주 쓰이는 컬럼은 인덱스로 지정하여 검색 비용을 줄이는 것도 잊지 말자.

 

컬럼명에 숫자를 쓰는 일은 없도록 하자 

또한 fk로 지정된 컬럼이라고 혹여 fk_id 라는 식으로 앞에 fk라 명명 하는 일도 없도록 하자.

fk인것은 알수 있을 지언정, 어차피 컬럼명만 봐서는 어떤 테이블과 관계를 맺고 있는지 유추는 불가능하다.

( 한마디로 부질 없는 짓이다 )
```

## db테이블 네이밍 컨벤션
```
이름은 snake case를 따른다.
snake case란 모든 글자를 소문자로 하고, 언더스코어(_)로 단어를 구분해주는 방법
ex) userLogin, Name (X) --> user_login, name (O)

prefix와 postfix는 사용하지 않는다. (옛날 방식)
ex) user_TB (X)

테이블의 이름은 복수가 아닌 단수로 쓴다.
ex) members (X) -> member (O)

가능하면 단어를 줄여쓰지 않는다. (no abbreviation)
ex) mid_ma (X) --> middle_name (O)

테이블이 하나의 Primary Key를 가진다면 그 속성의 이름은 id로 한다.
ex) user_id (X) -> id

index와 constraint는 descriptive하게 작성한다.
예를 들어 index의 경우 테이블명, 속성명, 인덱스 유형이 포함되어야 한다.
ex) user_ix (X) -> user_ix_email_lower

모든 식별자들은 소문자(Lowercase)로 작성한다.
ex) First_Name (X) -> first_name

단일 컬럼 primary key라면 이름을 id로 짓는다.
id는 짧고, 단순하고 명확하다.

foreign key 필드는 {참조되는 테이블}_id로 짓는다.

boolean type 의 prefix : is ex) (연결여부) is_linked
```

## 오라클의 데이터 타입
```
VARCHAR2(size)
	가변길이 문자 데이터 최대값: 4000 byte
	size 범위내에서 실제 데이터의 크기만큼만 저장공간을 사용한다.
	예) 이름, 주소, 과목명, 상품명, 뉴스제목 [ 길이들이 매번 달라질 수 있다 ]


CHAR(size)
	고정길이 문자 데이터 : 2000 byte
	size크기만큼의 저장공간을 무조건 사용한다.
	예) 주민번호, 학번, 수강과목코드,


LONG
	가변길이 대용량 문자 데이터, 최대값 : 2GB
	현재는 잘 사용되지 않음
	테이블당 하나 밖에 사용할 수 없다.
	제약조건을 정의할 수 없다.
	order by 나 group by에 포함시킬 수 없다.


CLOB ( Character Large OBject)
	가변길이 대용량 문자 데이터, 최대값: 4GB
	예) 블로그의 본문, 신문기사, 논문


NUMBER(p, s)
	가변길이 숫자 데이터
	p : 십진수의 총 갯수 , s : 소숫점이하 자릿수 ( 0 이면 정수 , 0이아니면 	전부 실수)


DATE
	날짜 및 시간 데이터
	예) 입사일 , 가입일, 주문날짜, 이체날짜, 신청날짜 ...


TIMESTAMP
	날짜 및 시간 데이터, 소수점 이하 초까지 포함한다.


BLOB (Binary Large OBject )
	가변길이 대용량 이진 데이터 , 최대값: 4GB
	예) 그림, 영상, 게임파일


ROWID
	테이블에서 행의 고유주소를 나타내는 64진수 숫자데이터
```

## 테이터베이스 관계선
```
관계선의 종류
	실선(Identifying): 식별관계
		부모테이블의 PK가 자식테이블의 FK/PK가 되는 경우
	 	부모가 있어야 자식이 생기는 경우
	 	
	점선(Non-Identifying): 비식별관계
		부모테이블의 PK가 자식테이블의 일반속성이 되는 경우
		부모가 없어도 자식이 생기는 경우
		
	｜: 1개 / 실선은(dash) ‘1'을 나타낸다.
	∈: 여러개 / 까마귀 발(crow’s foot or Many)은 ‘다수' 혹은 '그 	이상'을 나타낸다.
	○: 0개 / 고리(ring or Optional)은 ‘0'을 나타낸다.
	
	Type1(실선과 실선): 정확히 1 (하나의 A는 하나의 B로 이어져 있다.)
	Type2(까마귀발): 여러개 (하나의 A는 여러개의 B로 구성되어 있다.)
	Type3(실선과 까마귀발): 1개 이상 (하나의 A는 하나 이상의 B로 구성되어 있다.)
	Type4(고리와 실선): 0 혹은 1 (하나의 A는 하나 이하의 B로 구성되어 있다.)
	Type5(고리와 까마귀발): 0개 이상 (하나의 A는 0또는 하나 이상의 B로 구성되 있다.)

```
```
created_at : record 가 insert 된 시각. insert 때 값이 정해지고 이후 불변합니다.
updated_at : record 가 마지막으로 update 된 시각. insert 직후에는 created_at 컬럼의 값과 동일하고, 이후 update 때마다 값이 갱신됩니다.
```